# AUTOGENERATED! DO NOT EDIT! File to edit: ../10_model.ipynb.

# %% auto 0
__all__ = ['growth_factor_model']

# %% ../10_model.ipynb 2
import jax.numpy as jnp
import jax.scipy as jsp
import jax
from jax import vmap, jit
import matplotlib.pyplot as plt
import matplotlib as mpl

from isssm.typing import PGSSM, GLSSMState
from jaxtyping import Array, Float

from tensorflow_probability.substrates.jax.distributions import NegativeBinomial as NBinom

# %% ../10_model.ipynb 5
def _state_model(r0, u0, alpha, s2_rho, Omega, n) -> GLSSMState:
    x0 = jnp.concatenate([r0, u0])
    K, = u0.shape
    A = jnp.broadcast_to(
        jsp.linalg.block_diag(alpha, jnp.eye(K)),
        (n, K + 1, K + 1)
    )
    Sigma0 = 1e3 * jnp.eye(K + 1)
    Sigma = jnp.linalg.block_diag(s2_rho * jnp.eye(1), 1/(1 - alpha ** 2) * Omega)
    Sigma = jnp.concatenate([ 
        Sigma0[None, ...], 
        jnp.broadcast_to(Sigma, (n, K + 1, K + 1))
        ], axis=0)

    return GLSSMState(x0, A, Sigma)

# %% ../10_model.ipynb 7
def _observation_model(
        obs: Float[Array, "n+2 K"],
        P: Float[Array, "K K"],
        r: Float
    ):

    np2, p = obs.shape

    delayed_obs = obs[:-1]
    cases_adjusted = vmap(jnp.matmul, (None, 0))(P, delayed_obs)

    xi = jnp.concatenate((
        jnp.full((np2 - 1, p, 1), r),
        cases_adjusted[:,:, None]
    ), axis=-1)

    def dist_obs(signal, xi):
        r, sum_I =jnp.moveaxis(xi, -1, 0)
        return NBinom(r, logits=signal + jnp.log(sum_I))
    
    return dist_obs, xi

# %% ../10_model.ipynb 10
def _P(C, q, n_ij, n_tot) -> Float[Array, "K K"]:
    p, _ = n_ij.shape
    m_ij = n_ij + jnp.diag(C * n_tot - n_ij.sum(axis=1)) 
    normalize_rows = lambda x: x / x.sum(axis=1).reshape((-1,1))
    return jnp.full((p,p), q / p) + (1 - q) * normalize_rows(m_ij)

# %% ../10_model.ipynb 13
def growth_factor_model(
        theta,
        aux
    ) -> PGSSM:
    
    logit_alpha, log_s2_r, log_s2_spat, logit_q, C, log_r= theta
    obs, n_ij, n_tot= aux

    np2, _ = obs.shape
    np1 = np2 - 1
    K, = n_tot
    
    alpha = jsp.special.expit(logit_alpha)
    s2_rho = jnp.exp(log_s2_r)
    s2_spat = jnp.exp(log_s2_spat)
    r = jnp.exp(log_r)
    q = jsp.special.expit(logit_q)

    P = _P(C, q, n_ij, n_tot)
    state  = _state_model(jnp.zeros(1), jnp.zeros(K), alpha, s2_rho, s2_spat * P @ P.T)
    dist, xi = _observation_model(obs, P, r)

    B = jnp.broadcast_to(
        jnp.block([jnp.zeros((K, 1)), jnp.eye(K)]),
        (np1, K, K + 1)
    )

    return PGSSM(
        x0 = state.x0,
        A = state.A,
        Sigma = state.Sigma,
        B = B,
        dist = dist,
        xi = xi
    )
